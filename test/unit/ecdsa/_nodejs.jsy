const {assert, expect} = require('chai')
const {createSign, createVerify} = require('crypto')
const ec_pem = require('ec-pem')

import * as ecdsa from 'ecc-codec/esm/ecdsa/index.mjs'
import { u8_to_hex, hex_to_u8 } from 'u8-utils/esm/index.js'

const curveForName = @{}
  'P-256': 'prime256v1', 'prime256v1': 'prime256v1', 'secp256r1': 'prime256v1',
  'P-384': 'secp384r1', 'secp384r1': 'secp384r1',
  'P-521': 'secp521r1', 'secp521r1': 'secp521r1',

const hashAlgForName = @{}
  'SHA-256': 'SHA256', 'SHA256': 'SHA256',
  'SHA-384': 'SHA384', 'SHA384': 'SHA384',
  'SHA-512': 'SHA512', 'SHA512': 'SHA512',


export const test_ecdsa = test_ecdsa_nodejs
export async function test_ecdsa_nodejs(curve, hash_alg, utf8_data) ::
  const data = Buffer.from(utf8_data, 'utf8')

  const ec_priv = ec_pem.generate(curveForName[curve])
  const publicKey = ec_priv.getPublicKey().toString('hex')

  const sig_asn1 = createSign(hashAlgForName[hash_alg])
    .update(data)
    .sign @ ec_priv.encodePrivateKey()

  const sig_raw = ecdsa.encode_ecdsa_raw @
    ecdsa.decode_ecdsa_asn1 @ sig_asn1

  return validate_ecdsa_nodejs @:
    curve, hash_alg, utf8_data,
    sig_raw, sig_asn1, publicKey


export const validate_ecdsa = validate_ecdsa_nodejs
export async function validate_ecdsa_nodejs({curve, hash_alg, utf8_data, sig_raw, sig_asn1, publicKey}) ::
  const data = Buffer.from(utf8_data, 'utf8')

  if 'string' === typeof sig_raw ::
    sig_raw = hex_to_u8(sig_raw)

  if 'string' === typeof sig_asn1 ::
    sig_asn1 = hex_to_u8(sig_asn1)

  if 'string' !== typeof publicKey ::
    throw new TypeError @ `Expected publicKey to be a hex-encoded string buffer`

  publicKey = ec_pem(curveForName[curve])
    .setPublicKey @ publicKey, 'hex'
    .encodePublicKey()

  ::
    const ver = createVerify(hashAlgForName[hash_alg])
      .update(data)
      .verify @ publicKey, sig_asn1

    assert.equal @ ver, true, 'verify direct'

  ::
    const sig_r_s = ecdsa.decode_ecdsa_asn1 @ sig_asn1
    const rt_sig = ecdsa.encode_ecdsa_asn1 @ sig_r_s

    const ver = createVerify(hashAlgForName[hash_alg])
      .update(data)
      .verify @ publicKey, rt_sig

    assert.equal @ ver, true, 'verify ECDSA ASN1 roundtrip'
    assert.equal @ u8_to_hex(rt_sig), u8_to_hex(sig_asn1), 'ECDSA ASN1 roundtrip'

  ::
    const rt_sig = ecdsa.encode_ecdsa_asn1 @
      ecdsa.decode_ecdsa_raw @ sig_raw

    const ver = createVerify(hashAlgForName[hash_alg])
      .update(data)
      .verify @ publicKey, rt_sig

    assert.equal @ ver, true, 'verify ECDSA raw roundtrip'
    assert.equal @ u8_to_hex(rt_sig), u8_to_hex(sig_asn1), 'ECDSA raw roundtrip'

