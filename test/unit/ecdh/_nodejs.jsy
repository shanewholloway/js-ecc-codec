const { createECDH } = require('crypto')
const { assert, expect } = require('chai')

import * as ecc from 'ecc-codec/esm/node/ecc/index.mjs'
import * as ecdh from 'ecc-codec/esm/node/ecdh/api.mjs'
import { hex_to_u8 } from 'u8-utils/esm/index.js'

export const test_ecdh = test_ecdh_nodejs
export async function test_ecdh_nodejs(keyKind, curve, format) ::
  const ecdh_new_keys = await ecdh.ecdh_generateKey(curve)
  const ecdh_key = ecdh_new_keys[keyKind]
  const exp = await ecdh.ecdh_exportKey(format, ecdh_key)

  const rt_ecdh_key = 'publicKey' === keyKind
    ? await ecdh.ecdh_importPublicKey(curve, format, exp)
    : await ecdh.ecdh_importPrivateKey(curve, format, exp)

  //console.log @ JSON.stringify @: keyKind, curve, format, exported: exp

  ::
    assert.equal @
      0, Buffer.compare @ ecdh_key.getPublicKey(), rt_ecdh_key.getPublicKey()
      `Roundtrip public key mismatch for curve: ${curve} format ${format} ${keyKind}`

  if 'privateKey' === keyKind ::
    assert.equal @
      0, Buffer.compare @ ecdh_key.getPrivateKey(), rt_ecdh_key.getPrivateKey()
      `Roundtrip private key mismatch for curve: ${curve} format ${format} ${keyKind}`


export const validate_ecdh = validate_ecdh_nodejs
export async function validate_ecdh_nodejs({keyKind, curve, format, exported}) ::
  if 'string' === typeof exported ::
    exported = hex_to_u8(exported).buffer

  if 'publicKey' === keyKind ::
    await ecdh.ecdh_importPublicKey(curve, format, exported)
  else ::
    await ecdh.ecdh_importPrivateKey(curve, format, exported)

